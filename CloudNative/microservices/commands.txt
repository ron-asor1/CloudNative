Commands

dotnet new web -n ProductService
dotnet run

endpoints:

http://localhost:


##container

Run on same level as dockerfile:
    docker build -t productservice .
See list of images
    docker images
run docker images   
    docker run -d -p 8080:80 --name productservicecontainer productservice
run docker images interactive mode
    docker run -it --rm -p 8080:8080 --name productservicecontainer productservice
stop docker image
    docker stop productservicecontainer
login locally to docker
    docker login (will auto automatically if logged in on desktop)
tag image
    docker tag productservice ronasor1/productservice:latest
push image
    docker push ronasor1/productservice:latest

dockerhub: https://hub.docker.com/repository/docker/ronasor1/productservice/general


container flow 
Write dockerFile
Build docker image
run docker container
test run locally
tag docker container
publish image to regsitrey such as dockrHub
deploy to cloud


##
pushing docker image to amazon ECR
 1. create amazon ECR repo
 2. authenticate docker to amazon ecr registery
 3. builder docker image
 4. tag docker image
 5. push docker to amazon ecr
 create amazon ECR:
    name - productservice

authenticate docker to amazon ECR registery 
    aws ecr get-login-password --region eu-north-1 | docker login --username AWS --password-stdin 688567289104.dkr.ecr.eu-north-1.amazonaws.com

build docer image
    docker build -t productservice .

tag docker image
    docker tag productservice:latest 688567289104.dkr.ecr.eu-north-1.amazonaws.com/productservice

push docker image
    docker push 688567289104.dkr.ecr.eu-north-1.amazonaws.com/productservice:latest


##
starting with minikube
    start docker desktop
    start minikube
    interact with cluster
        kubectl get po -A
    alternative
        minikube kubectl -- g po -AWS
    see k8s is up and running

    see dashboard
        minikube dashboard


ASP.NET container expose port - configur to listen - 0.0.0.0:8080
    >directly into program
        var port = Environment.GetEnvironmentVariable("PORT") ?? "8080";
        var url = $"http://0.0.0.0:{port}";
        builder.WebHost.UseUrls(url);
    >(alternative) docker dockerFile
        add new vairable into dockerFile
            https://github.com/dotnet/dotnet-docker/issues/3968
        "environmentVariables" :{
            "ASPNETCORE_URL": "https://+:443;http://+:8080",
            "ASPNETCORE_HTTPS_PORT": "44360"
        },
    >k8s deployment ENV variable inject
        https://www.youtube.com/watch?v=63FLcPHUCPM
        dk 46.11

        kestrel__endpoints__http__url
        http://0.0.0.0:8080

PODS
    the pod is a container running in kubernetes.
    a pod is bascically a running container on a Node or VM. 
    pod definition cna be created via kubectl command impoeratively from arguments or declarively from a configrationn file.
    use kubectl command to write our configruation files.

creating pod definition
    establish yaml file
    view if pods are live
        kubectl get pod
    view all kubectl traffic
        kubectl get all
    open terminal to watch created pods on k8s
        kubectl get pods -watch
apply configration for single pod
        kubectl apply -f product-pod.yaml
        - will create a pod in kubernetes
    expose the pod
        kubectl port-forward product-pod 8080:8080
apply configration for deployment
        kubectl apply -f product-deploy.yaml
        - will create a pod in kubernetes
apply configration for service
        kubectl apply -f product-service.yaml
        - will create a pod in kubernetes
        kubectl port-forward service/product-service 7080:8080
>>expose service with minikube 
    minkube service product-service


cleanup
    kubectl delete pod product-pod
    or
    kubectl delete -f .\product-pod.yaml

>>ingress - Define set of rules when allowing external source to reach services and using api calls.
 
getMinikube IP 
    minikube ip : 192.168.49.2

> edit host 
#Added by minikube custome domain 
192.168.49.2 product.local

deploy of ingress:
    1. first activate ingress addon into minikube installment
        minikube addons list
        minikube addons enable ingress
        minikube addons enable ingress-dns

    kubectl get ingress

    2. track minikube (in sepearate terminal)
    minikube tunnel

    ingress reach for products service:
    http://product.local/api/products

congirue configMap & secret
    create secret-key encoded in base64, using bash
        echo -n 'product-api-key' | base64
        cHJvZHVjdC1hcGkta2V5
    
    >additional command
        kubectl get secret
        kubectl get configmap

modify .NET application to read these enironment variables and use them as needed.
there are typical ENV variable that we can use into our application
    goto program.cs

    var logLevel = Environment.GetEnvironmentVariable("LOG_LEVEL");
    VAR apiKey = Environment.GetEnvironmentVariable("API_KEY");

>>scale container instance in kubernetes
    we can manually scale directly from yaml file -recplias
    or while instance running
        to watch service live
            kubectl get pod -w
    scale up
        kubectl scale --replicas=5 deployment/product  
    scale down
        kubectl scale --replicas=1 deployment/product  

>>if theres a failure, k8s will auto restart the pods that were running
    we can manually delete a pod and validate k8s restarted a new pod to always match the number of replicas defined
        kubectl delete pod <pod name>
    then check pods status
        kube get pod